
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="shortcut icon" href="favicon.ico">
  <title>hara.component - constructing composable systems</title>
  <script src="js/highlight.min.js"></script>
  <script src="js/gumshoe.min.js"></script>
  <script src="js/smooth-scroll.min.js"></script>
  
  <!-- CSS -->
  <link rel="stylesheet" href="css/poole.css">
  <link rel="stylesheet" href="css/syntax.css">
  <link rel="stylesheet" href="css/lanyon.css">
  <link rel="stylesheet" href="css/bolton.css">
  <link rel="stylesheet" href="css/bolton-api.css">
  <link rel="stylesheet" href="css/bolton-highlight.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">
  
</head>

  <body class="theme-base-08">
    <span id="page-top"></span>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <nav class="sidebar-nav">
    <span>&nbsp;</span>
    <a class="sidebar-nav-item header" href="index.html"><img src="img/logo-white.png"/></a>
    <span>&nbsp;</span>
    <a class="sidebar-nav-item" href="hara-benchmark.html">benchmark</a><a class="sidebar-nav-item" href="hara-class.html">class</a><a class="sidebar-nav-item" href="hara-common.html">common</a><a class="sidebar-nav-item active" href="hara-component.html">component</a><a class="sidebar-nav-item" href="hara-concurrent.html">concurrent</a><a class="sidebar-nav-item" href="hara-concurrent-ova.html">concurrent.ova</a><a class="sidebar-nav-item" href="hara-concurrent-procedure.html">concurrent.procedure</a><a class="sidebar-nav-item" href="hara-data.html">data</a><a class="sidebar-nav-item" href="hara-event.html">event</a><a class="sidebar-nav-item" href="hara-expression.html">expression</a><a class="sidebar-nav-item" href="hara-extend.html">extend</a><a class="sidebar-nav-item" href="hara-function.html">function</a><a class="sidebar-nav-item" href="hara-group.html">group</a><a class="sidebar-nav-item" href="hara-io.html">io</a><a class="sidebar-nav-item" href="hara-io-file.html">io.file</a><a class="sidebar-nav-item" href="hara-io-profiler.html">io.profiler</a><a class="sidebar-nav-item" href="hara-io-scheduler.html">io.scheduler</a><a class="sidebar-nav-item" href="hara-io-watch.html">io.watch</a><a class="sidebar-nav-item" href="hara-namespace.html">namespace</a><a class="sidebar-nav-item" href="hara-object.html">object</a><a class="sidebar-nav-item" href="hara-reflect.html">reflect</a><a class="sidebar-nav-item" href="hara-security.html">security</a><a class="sidebar-nav-item" href="hara-sort.html">sort</a><a class="sidebar-nav-item" href="hara-string.html">string</a><a class="sidebar-nav-item" href="hara-test.html">test</a><a class="sidebar-nav-item" href="hara-time.html">time</a><a class="sidebar-nav-item" href="hara-zip.html">zip</a>
    <span class="sidebar-nav-item">&nbsp;</span>
    <span class="sidebar-nav-item">&nbsp;</span>
  </nav>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <span>hara.component</span>
            <small>constructing composable systems</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="page">
          <div class="heading">
            <div>
              <h5>Author: Chris Zheng&nbsp;&nbsp;<a href="mailto:z@caudate.me">(z@caudate.me)</a></h5>
              <h5>Date: 29 June 2017</h5>
              <h5>Repository: <a href="https://github.com/zcaudate/hara">https://github.com/zcaudate/hara</a></h5>
              <h5>Version: 2.5.10</h5></div></div>
          <hr/>
          <div class="outline">
            <div class="toc">
              <nav data-gumshoe-header>
                <ul data-gumshoe>
                  <a data-scroll class="top" href="#page-top">TOP</a>
                  <li><a class="chapter" data-scroll="" href="#introduction"><h4>1 &nbsp; Introduction</h4></a><a class="section" data-scroll="" href="#installation"><h5><i>1.1 &nbsp; Installation</i></h5></a><a class="section" data-scroll="" href="#motivation"><h5><i>1.2 &nbsp; Motivation</i></h5></a></li><li><a class="chapter" data-scroll="" href="#api"><h4>2 &nbsp; API</h4></a><a class="section" data-scroll="" href="#entry__hara_component__component_QMARK_"><h5><i>component?</i></h5></a><a class="section" data-scroll="" href="#entry__hara_component__system"><h5><i>system</i></h5></a><a class="section" data-scroll="" href="#entry__hara_component__system_QMARK_"><h5><i>system?</i></h5></a><a class="section" data-scroll="" href="#entry__hara_component__start"><h5><i>start</i></h5></a><a class="section" data-scroll="" href="#entry__hara_component__stop"><h5><i>stop</i></h5></a><a class="section" data-scroll="" href="#entry__hara_component__started_QMARK_"><h5><i>started?</i></h5></a><a class="section" data-scroll="" href="#entry__hara_component__stopped_QMARK_"><h5><i>stopped?</i></h5></a><a class="section" data-scroll="" href="#entry__hara_component__properties"><h5><i>properties</i></h5></a></li><li><a class="chapter" data-scroll="" href="#config-driven-design"><h4>3 &nbsp; Config Driven Design</h4></a><a class="section" data-scroll="" href="#the-bug-trapper"><h5><i>3.1 &nbsp; The Bug Trapper</i></h5></a><a class="section" data-scroll="" href="#configuration"><h5><i>3.2 &nbsp; Configuration</i></h5></a></li><li><a class="chapter" data-scroll="" href="#probability-model"><h4>4 &nbsp; Probability Model</h4></a><a class="section" data-scroll="" href="#linear-adjustment"><h5><i>4.1 &nbsp; linear-adjustment</i></h5></a><a class="section" data-scroll="" href="#toggle-adjustment"><h5><i>4.2 &nbsp; toggle-adjustment</i></h5></a><a class="section" data-scroll="" href="#add-distributions"><h5><i>4.3 &nbsp; add-distributions</i></h5></a><a class="section" data-scroll="" href="#adjusted-distribution"><h5><i>4.4 &nbsp; adjusted-distribution</i></h5></a></li><li><a class="chapter" data-scroll="" href="#sampling-model"><h4>5 &nbsp; Sampling Model</h4></a><a class="section" data-scroll="" href="#cumultive"><h5><i>5.1 &nbsp; cumultive</i></h5></a><a class="section" data-scroll="" href="#category"><h5><i>5.2 &nbsp; category</i></h5></a><a class="section" data-scroll="" href="#random-sample"><h5><i>5.3 &nbsp; random-sample</i></h5></a></li><li><a class="chapter" data-scroll="" href="#implementing-components"><h4>6 &nbsp; Implementing Components</h4></a><a class="section" data-scroll="" href="#model"><h5><i>6.1 &nbsp; Model</i></h5></a><a class="section" data-scroll="" href="#trap"><h5><i>6.2 &nbsp; Trap</i></h5></a><a class="section" data-scroll="" href="#partial-system-testing"><h5><i>6.3 &nbsp; Partial System Testing</i></h5></a><a class="section" data-scroll="" href="#app"><h5><i>6.4 &nbsp; App</i></h5></a><a class="section" data-scroll="" href="#app-testing"><h5><i>6.5 &nbsp; App Testing</i></h5></a><a class="section" data-scroll="" href="#server"><h5><i>6.6 &nbsp; Server</i></h5></a><a class="section" data-scroll="" href="#server-testing"><h5><i>6.7 &nbsp; Server Testing</i></h5></a></li><li><a class="chapter" data-scroll="" href="#the-big-picture"><h4>7 &nbsp; The Big Picture</h4></a><a class="section" data-scroll="" href="#summary"><h5><i>7.1 &nbsp; Summary</i></h5></a><a class="section" data-scroll="" href="#further-extension"><h5><i>7.2 &nbsp; Further Extension</i></h5></a></li><li><a class="chapter" data-scroll="" href="#links-and-resources"><h4>8 &nbsp; Links and Resources</h4></a></li>
                </ul>
              </nav>
            </div>
          </div>

          <div class="toc">
              <nav>
                <ul>
                  <li><a class="chapter" data-scroll="" href="#introduction"><h4>1 &nbsp; Introduction</h4></a><a class="section" data-scroll="" href="#installation"><h5><i>1.1 &nbsp; Installation</i></h5></a><a class="section" data-scroll="" href="#motivation"><h5><i>1.2 &nbsp; Motivation</i></h5></a></li><li><a class="chapter" data-scroll="" href="#api"><h4>2 &nbsp; API</h4></a><a class="section" data-scroll="" href="#entry__hara_component__component_QMARK_"><h5><i>component?</i></h5></a><a class="section" data-scroll="" href="#entry__hara_component__system"><h5><i>system</i></h5></a><a class="section" data-scroll="" href="#entry__hara_component__system_QMARK_"><h5><i>system?</i></h5></a><a class="section" data-scroll="" href="#entry__hara_component__start"><h5><i>start</i></h5></a><a class="section" data-scroll="" href="#entry__hara_component__stop"><h5><i>stop</i></h5></a><a class="section" data-scroll="" href="#entry__hara_component__started_QMARK_"><h5><i>started?</i></h5></a><a class="section" data-scroll="" href="#entry__hara_component__stopped_QMARK_"><h5><i>stopped?</i></h5></a><a class="section" data-scroll="" href="#entry__hara_component__properties"><h5><i>properties</i></h5></a></li><li><a class="chapter" data-scroll="" href="#config-driven-design"><h4>3 &nbsp; Config Driven Design</h4></a><a class="section" data-scroll="" href="#the-bug-trapper"><h5><i>3.1 &nbsp; The Bug Trapper</i></h5></a><a class="section" data-scroll="" href="#configuration"><h5><i>3.2 &nbsp; Configuration</i></h5></a></li><li><a class="chapter" data-scroll="" href="#probability-model"><h4>4 &nbsp; Probability Model</h4></a><a class="section" data-scroll="" href="#linear-adjustment"><h5><i>4.1 &nbsp; linear-adjustment</i></h5></a><a class="section" data-scroll="" href="#toggle-adjustment"><h5><i>4.2 &nbsp; toggle-adjustment</i></h5></a><a class="section" data-scroll="" href="#add-distributions"><h5><i>4.3 &nbsp; add-distributions</i></h5></a><a class="section" data-scroll="" href="#adjusted-distribution"><h5><i>4.4 &nbsp; adjusted-distribution</i></h5></a></li><li><a class="chapter" data-scroll="" href="#sampling-model"><h4>5 &nbsp; Sampling Model</h4></a><a class="section" data-scroll="" href="#cumultive"><h5><i>5.1 &nbsp; cumultive</i></h5></a><a class="section" data-scroll="" href="#category"><h5><i>5.2 &nbsp; category</i></h5></a><a class="section" data-scroll="" href="#random-sample"><h5><i>5.3 &nbsp; random-sample</i></h5></a></li><li><a class="chapter" data-scroll="" href="#implementing-components"><h4>6 &nbsp; Implementing Components</h4></a><a class="section" data-scroll="" href="#model"><h5><i>6.1 &nbsp; Model</i></h5></a><a class="section" data-scroll="" href="#trap"><h5><i>6.2 &nbsp; Trap</i></h5></a><a class="section" data-scroll="" href="#partial-system-testing"><h5><i>6.3 &nbsp; Partial System Testing</i></h5></a><a class="section" data-scroll="" href="#app"><h5><i>6.4 &nbsp; App</i></h5></a><a class="section" data-scroll="" href="#app-testing"><h5><i>6.5 &nbsp; App Testing</i></h5></a><a class="section" data-scroll="" href="#server"><h5><i>6.6 &nbsp; Server</i></h5></a><a class="section" data-scroll="" href="#server-testing"><h5><i>6.7 &nbsp; Server Testing</i></h5></a></li><li><a class="chapter" data-scroll="" href="#the-big-picture"><h4>7 &nbsp; The Big Picture</h4></a><a class="section" data-scroll="" href="#summary"><h5><i>7.1 &nbsp; Summary</i></h5></a><a class="section" data-scroll="" href="#further-extension"><h5><i>7.2 &nbsp; Further Extension</i></h5></a></li><li><a class="chapter" data-scroll="" href="#links-and-resources"><h4>8 &nbsp; Links and Resources</h4></a></li>
                </ul>
              </nav>
          </div>
          <div><span id="introduction"></span><h2><b>1 &nbsp;&nbsp; Introduction</b></h2></div><div><p><a href='https://github.com/zcaudate/hara/blob/master/src/hara/component.clj'>hara.component</a> is a dependency injection framework for clojure. The virtues of this type of design for composing large systems has been much lauded. This library places emphasis on building large systems using a toplogy of how subsystems fit together and data of how it is to be configured.</p></div><div><span id="installation"></span><h3>1.1 &nbsp;&nbsp; Installation</h3></div><div><p>Add to <code>project.clj</code> dependencies:</p><pre><code>&#91;zcaudate/hara.component &quot;2.5.10&quot;&#93;</code></pre></div><div><p>All functions are in the <code>hara.component</code> namespace.</p></div><div class="code"><pre><code class="clojure">(require '[hara.component :as component])</code></pre></div><div><span id="motivation"></span><h3>1.2 &nbsp;&nbsp; Motivation</h3></div><div><p>There are two existing component libraries, namely:  </p><ul><li><a href='https://github.com/stuartsierra/component'>component</a></li><li><a href='https://github.com/tolitius/mount'>mount</a></li></ul><p><code>hara.component</code> takes the more simplified idea proposed by the <a href='https://github.com/stuartsierra/component'>original</a> library where there is whole system start up and teardown. However, it extends upon that concept by teasing apart configuration and application topology to give cleaner notion of design.</p><p>Configuration gives the ability to set the starting state of the entire program and should be easy as possible. Many a system become bloated due to not being able to properly manage configuration, therefore composing systems with configuration at the forefront will make for much simpler code and design. This library was build with this paradigm in mind. </p><p>Additionally, there are additional features that enable developers to write their systems in a clearer fashion.</p><ul><li>support for dealing with arrays of component</li><li>control with nested systems</li></ul></div><div><span id="api"></span><h2><b>2 &nbsp;&nbsp; API</b></h2></div><div><p>Because component is a framework for building systems, we have to start off with concepts of what we wish to build:</p><ul><li>A <code>Catalog</code> searches through files in a smart way and consists of a <code>FileSystem</code> and a <code>Database</code></li><li>A <code>Filesystem</code> stores and manages files</li><li>A <code>Database</code> stores indexed information about files</li></ul><p>The most simple representation is:</p></div><div class="code"><pre><code class="clojure">(defrecord Database []
  component/IComponent
  (-start [db]
    (assoc db :status &quot;started&quot;))
  (-stop [db]
    (dissoc db :status)))

(defrecord Filesystem []
  component/IComponent
  (-start [fs]
    (assoc fs :status &quot;started&quot;))
  (-stop [fs]
    (dissoc fs :status)))

(defrecord Catalog []
  component/IComponent
  (-start [store]
    (assoc store :status &quot;started&quot;))
  (-stop [store]
    (dissoc store :status)))</code></pre></div><div><p>These definitions are then used in context of specifying a system consisting of two <code>Catalog</code> instances, having the same <code>Database</code> instance, but different <code>Filesystem</code> instances.</p></div><div class="api"><span id="entry__hara_component__"></span><hr /><div><ul><li><a data-scroll="" href="#entry__hara_component__component_QMARK_">component?</a></li><li><a data-scroll="" href="#entry__hara_component__system">system</a></li><li><a data-scroll="" href="#entry__hara_component__system_QMARK_">system?</a></li><li><a data-scroll="" href="#entry__hara_component__start">start</a></li><li><a data-scroll="" href="#entry__hara_component__stop">stop</a></li><li><a data-scroll="" href="#entry__hara_component__started_QMARK_">started?</a></li><li><a data-scroll="" href="#entry__hara_component__stopped_QMARK_">stopped?</a></li><li><a data-scroll="" href="#entry__hara_component__properties">properties</a></li></ul><hr style="margin-bottom: 0" /><div><div class="entry"><span id="entry__hara_component__component_QMARK_"></span><div class="entry-description"><h4><b>component?&nbsp<a data-scroll="" href="#entry__hara_component__">^</a></b></h4><p><i>checks if an instance extends IComponent</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/component.clj#L38-L45" target="_blank">v&nbsp;2.2</a></h6><div><input class="source-toggle" id="entry__pre_hara_component__component_QMARK_" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_component__component_QMARK_"></label><pre class="source"><code class="clojure">(defn component?
  [x]
  (extends? IComponent (type x)))</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/component_test.clj#L356-L359" target="_blank">link</a></i></h6><code class="clojure">(component? (Database.))
=> true</code></pre></div><div class="entry"><span id="entry__hara_component__system"></span><div class="entry-description"><h4><b>system&nbsp<a data-scroll="" href="#entry__hara_component__">^</a></b></h4><p><i>creates a system of components</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/component.clj#L543-L613" target="_blank">v&nbsp;2.1</a></h6><div><input class="source-toggle" id="entry__pre_hara_component__system" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_component__system"></label><pre class="source"><code class="clojure">(defn system
  ([topology config]
   (system topology config {:partial false}))
  ([topology config {:keys [partial? tag display] :as opts}]
   (let [full   (long-form topology)
         valid  (valid-subcomponents full (keys config))
         expose (get-exposed full)
         diff   (set/difference (set (keys full)) valid)
         _      (or (empty? diff)
                    partial?
                    (throw (Exception. (str "Missing Config Keys: " diff))))
         build  (apply dissoc full diff)
         dependencies (apply dissoc (get-dependencies full) diff)
         order (topological-sort dependencies)
         initial  (apply dissoc build (concat diff (get-exposed full)))]
     (-> (reduce-kv (fn [sys k {:keys [constructor compile] :as build}]
                      
                      (let [cfg (get config k)]
                        (assoc sys k (cond (= compile :array)
                                           (array build cfg)
                                           
                                           :else
                                           (constructor cfg)))))
                    (ComponentSystem.)
                    initial)
         (with-meta (merge {:partial (not (empty? diff))
                            :build   build
                            :order   order
                            :dependencies dependencies}
                           opts))))))</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/component_test.clj#L127-L166" target="_blank">link</a></i></h6><code class="clojure">;; The topology specifies how the system is linked
(def topo {:db        [map->Database]
           :files     [[map->Filesystem]]
           :catalogs  [[map->Catalog] [:files {:type :element :as :fs}] :db]})
  
;; The configuration customises the system
(def cfg  {:db     {:type :basic
                    :host "localhost"
                    :port 8080}
           :files [{:path "/app/local/1"}
                   {:path "/app/local/2"}]
           :catalogs [{:id 1}
                      {:id 2}]})
  
;; `system` will build it and calling `start` initiates it
(def sys (-> (system topo cfg) start))
  
;; Check that the `:db` entry has started
(:db sys)
=> (just {:status "started",
          :type :basic,
          :port 8080,
          :host "localhost"})

;; Check the first `:files` entry has started
(-> sys :files first)
=> (just {:status "started",
          :path "/app/local/1"})

;; Check that the second `:store` entry has started
(->> sys :catalogs second)
=> (contains-in {:id 2
                 :status "started"
                 :db {:status "started",
                      :type :basic,
                      :port 8080,
                      :host "localhost"}
                 :fs {:path "/app/local/2", :status "started"}})</code></pre></div><div class="entry"><span id="entry__hara_component__system_QMARK_"></span><div class="entry-description"><h4><b>system?&nbsp<a data-scroll="" href="#entry__hara_component__">^</a></b></h4><p><i>checks if object is a component system</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/component.clj#L327-L334" target="_blank">v&nbsp;2.1</a></h6><div><input class="source-toggle" id="entry__pre_hara_component__system_QMARK_" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_component__system_QMARK_"></label><pre class="source"><code class="clojure">(defn system?
  [x]
  (instance? ComponentSystem x))</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/component_test.clj#L170-L173" target="_blank">link</a></i></h6><code class="clojure">(system? (system {} {}))
=> true</code></pre></div><div class="entry"><span id="entry__hara_component__start"></span><div class="entry-description"><h4><b>start&nbsp<a data-scroll="" href="#entry__hara_component__">^</a></b></h4><p><i>starts a component/array/system</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/component.clj#L117-L137" target="_blank">v&nbsp;2.1</a></h6><div><input class="source-toggle" id="entry__pre_hara_component__start" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_component__start"></label><pre class="source"><code class="clojure">(defn start
  ([component]
   (start component {}))
  ([component {:keys [setup hooks] :as opts}]
   (let [{:keys [pre-start post-start]} hooks
         functions (or (get component :functions)
                       (get opts :functions))
         setup     (or setup identity)
         component   (-> component
                         (perform-hooks functions pre-start)
                         (-start)
                         (setup)
                         (perform-hooks functions post-start))]
     (if (iobj? component)
       (vary-meta component assoc :started true)
       component))))</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/component_test.clj#L87-L90" target="_blank">link</a></i></h6><code class="clojure">(start (Database.))
=> {:status "started"}</code></pre></div><div class="entry"><span id="entry__hara_component__stop"></span><div class="entry-description"><h4><b>stop&nbsp<a data-scroll="" href="#entry__hara_component__">^</a></b></h4><p><i>stops a component/array/system</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/component.clj#L139-L158" target="_blank">v&nbsp;2.1</a></h6><div><input class="source-toggle" id="entry__pre_hara_component__stop" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_component__stop"></label><pre class="source"><code class="clojure">(defn stop
  ([component]
   (stop component {}))
  ([component {:keys [teardown hooks] :as opts}]
   (let [{:keys [pre-stop post-stop]} hooks
         functions (or (get component :functions)
                       (get opts :functions))
         teardown  (or teardown identity)
         component (-> component
                       (perform-hooks functions pre-stop)
                       (teardown)
                       (-stop)
                       (perform-hooks functions post-stop))]
     (if (iobj? component)
       (vary-meta component dissoc :started)
       component))))</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/component_test.clj#L93-L95" target="_blank">link</a></i></h6><code class="clojure">(stop (start (Database.))) => {}</code></pre></div><div class="entry"><span id="entry__hara_component__started_QMARK_"></span><div class="entry-description"><h4><b>started?&nbsp<a data-scroll="" href="#entry__hara_component__">^</a></b></h4><p><i>checks if a component has been started</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/component.clj#L47-L77" target="_blank">v&nbsp;2.1</a></h6><div><input class="source-toggle" id="entry__pre_hara_component__started_QMARK_" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_component__started_QMARK_"></label><pre class="source"><code class="clojure">(defn started?
  [component]
  (try (-started? component)
       (catch IllegalArgumentException e
         (if (iobj? component)
           (-> component meta :started true?)
           (primitive? component)))
       (catch AbstractMethodError e
         (if (iobj? component)
           (-> component meta :started true?)
           (primitive? component)))))</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/component_test.clj#L45-L63" target="_blank">link</a></i></h6><code class="clojure">(started? 1)
=> true

(started? {})
=> false
  
(started? (start {}))
=> true
  
(started? (Database.))
=> false

(started? (start (Database.)))
=> true

(started? (stop (start (Database.))))
=> false</code></pre></div><div class="entry"><span id="entry__hara_component__stopped_QMARK_"></span><div class="entry-description"><h4><b>stopped?&nbsp<a data-scroll="" href="#entry__hara_component__">^</a></b></h4><p><i>checks if a component has been stopped</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/component.clj#L79-L105" target="_blank">v&nbsp;2.1</a></h6><div><input class="source-toggle" id="entry__pre_hara_component__stopped_QMARK_" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_component__stopped_QMARK_"></label><pre class="source"><code class="clojure">(defn stopped?
  [component]
  (try (-stopped? component)
       (catch IllegalArgumentException e
         (-> component started? not))
       (catch AbstractMethodError e
         (-> component started? not))))</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/component_test.clj#L66-L84" target="_blank">link</a></i></h6><code class="clojure">(stopped? 1)
=> false

(stopped? {})
=> true
  
(stopped? (start {}))
=> false
  
(stopped? (Database.))
=> true

(stopped? (start (Database.)))
=> false

(stopped? (stop (start (Database.))))
=> true</code></pre></div><div class="entry"><span id="entry__hara_component__properties"></span><div class="entry-description"><h4><b>properties&nbsp<a data-scroll="" href="#entry__hara_component__">^</a></b></h4><p><i>returns properties of the system</i></p></div><div class="entry-option"><h6><a href="https://github.com/zcaudate/hara/blob/master/src/hara/component.clj#L160-L172" target="_blank">v&nbsp;2.1</a></h6><div><input class="source-toggle" id="entry__pre_hara_component__properties" type="checkbox" /><label class="source-toggle" for="entry__pre_hara_component__properties"></label><pre class="source"><code class="clojure">(defn properties
  [component]
  (try (-properties component)
       (catch IllegalArgumentException e
         {})
       (catch AbstractMethodError e
         {})))</code></pre></div></div><pre><h6><i><a href="https://github.com/zcaudate/hara/blob/master/test/hara/component_test.clj#L98-L102" target="_blank">link</a></i></h6><code class="clojure">(properties (Database.)) => {}

(properties (Filesystem.)) => {:hello "world"}</code></pre></div></div></div></div><div><span id="config-driven-design"></span><h2><b>3 &nbsp;&nbsp; Config Driven Design</b></h2></div><div><p>Following on from the general concepts we have have a look at how such a framework can be used in practice.</p><p>We will aim to create a system based upon a configuration file. As components are a very high level concept, using the pattern in code is more of a state of mind than following a set of APIs. Therefore in this documentation, it is hoped that a tutorial based approach will demonstrate the core functionality within the library. We seperate the guide into the following sections</p><ul><li><a href='#probability-model'>Probability Model</a> - How to calculate a bug distribution model.</li><li><a href='#sampling-model'>Sampling Model</a> - How to sample the distribution model.</li><li><a href='#implementing-components'>Implementing Components</a> - How to create and pretty up components so they are easy to integrate.</li><li><a href='#the-big-picture'>The Big Picture</a> - How to think about building and extending systems</li></ul><p>The first two chapters are not really about components, but it is important in showing how to create functions based around a particular configuration. The rest of the sections take a comphrensive approach of how to configure and reason about entire systems based on the component approach.</p></div><div><span id="the-bug-trapper"></span><h3>3.1 &nbsp;&nbsp; The Bug Trapper</h3></div><div><p>We are creating a simulation based on trapping bugs in different parts of the house, then tallying up the results and displaying it through a web interface. We can see how the sub-systems connect together in the diagram below:</p></div><div class="figure"><a id="sub-system-dependencies"></a><h4><i>fig.1  &nbsp;-&nbsp; sub-system dependencies</i></h4><div class="img"><img height="400px" line="{:row 99, :col 1, :end-row 99, :end-col 103}" src="img/hara_component/dependency.png" title="sub-system dependencies" /></div><p></p></div><div><p>At the very bottom is a statistical model for generating events ie, how often an insect would be likely to appear given a certain set of conditions such as brightness, dampness, if it is indoors or outdoors, etc. This is used by a number of <code>traps</code>, which are an array of devices that simulates events of an insect going into the trap. An insect may or may not be captured by the trap itself and this is also tallied. The <code>app</code> itself tracks events over time by putting results into a <em>'database'</em> and the server takes live results and outputs a string via http.</p></div><div><span id="configuration"></span><h3>3.2 &nbsp;&nbsp; Configuration</h3></div><div><p>A datastructure can be created that customises various aspects of the simulation:</p></div><div class="code"><pre><code class="clojure">(def config
  {:server     {:port 8090}
   :app        {}
   :traps     ^{:fuzziness 0.1 :efficiency 0.6}
               [{:location &quot;kitchen&quot;  :brightness 0.3
                 :indoor true :rate 0.5}
                {:location &quot;bedroom&quot;  :brightness 0.1
                 :dampness 0.2 :indoor true :rate 0.3  :efficiency 0.2}
                {:location &quot;patio&quot;    :brightness 0.5
                 :outdoor true :rate 1.5  :efficiency 0.1}
                {:location &quot;bathroom&quot; :dampness 0.3
                 :indoor true :rate 0.2  :efficiency 0.3}]
   :db         {}
   :model      {:default {:fly 0.5 :ladybug 0.05
                          :mosquito 0.35 :bee 0.1}
                :linear  {:brightness {:bee 0.5}
                          :dampness   {:mosquito 0.4}}
                :toggle  {:indoor     {:fly 0.3
                                       :mosquito 0.2}
                          :outdoor    {:bee 0.1
                                       :ladybug 0.1}}}})</code></pre></div><div><span id="probability-model"></span><h2><b>4 &nbsp;&nbsp; Probability Model</b></h2></div><div><p>We have a model of what percentage of bugs and depending on location, brightness and dampness, we adjust our model accordingly. So for example, we should be able to write a function <code>adjusted-distribution</code> that takes in a model and some parameter settings and spits out a probability distribution in the form of a map:</p></div><div class="code"><pre><code class="clojure">(adjusted-distribution {} (-&gt; config :model))
=&gt; {:fly 0.5, :ladybug 0.05, :mosquito 0.35, :bee 0.1}

(adjusted-distribution {:indoor true}
                       (-&gt; config :model))
=&gt; {:fly 0.8, :ladybug 0.05, :mosquito 0.55, :bee 0.1}</code></pre></div><div><span id="linear-adjustment"></span><h3>4.1 &nbsp;&nbsp; linear-adjustment</h3></div><div><p>We write a functions to adjustment for the linear increase:</p></div><div class="code"><pre><code class="clojure">(defn linear-adjustment [params linear]
  (reduce-kv (fn [m k stats]
               (if-let [mul (get params k)]
                 (reduce-kv (fn [m k v]
                              (update-in m [k] (fnil #(+ % (* mul v))
                                                      0)))
                            m
                            stats)
                 m))
             {}
             linear))</code></pre></div><div><p>It can be applied to the model:</p></div><div class="code"><pre><code class="clojure">(linear-adjustment {:brightness 0.1}
                   (-&gt; config :model :linear))
=&gt; {:bee 0.05}

(linear-adjustment {:brightness 0.2}
                   (-&gt; config :model :linear))
=&gt; {:bee 0.1}

(linear-adjustment {:brightness 0.3}
                   (-&gt; config :model :linear))
=&gt; {:bee 0.15}

(linear-adjustment {:dampness 0.5}
                   (-&gt; config :model :linear))
=&gt; {:mosquito 0.2}</code></pre></div><div><span id="toggle-adjustment"></span><h3>4.2 &nbsp;&nbsp; toggle-adjustment</h3></div><div><p>The second function is for toggle adjustment, meaning that depending on a particular flag, we add a certain amount to the overall distribution:</p></div><div class="code"><pre><code class="clojure">(defn toggle-adjustment [params toggle]
  (reduce-kv (fn [m k stats]
               (if-let [mul (get params k)]
                 (reduce-kv (fn [m k v]
                              (update-in m [k] (fnil #(+ % v)
                                                     0)))
                            m
                            stats)
                 m))
             {}
             toggle))</code></pre></div><div><p>It can be applied to the model:</p></div><div class="code"><pre><code class="clojure">(toggle-adjustment {:indoor true}
                   (-&gt; config :model :toggle))
=&gt; {:fly 0.3, :mosquito 0.2}

(toggle-adjustment {:outdoor true}
                   (-&gt; config :model :toggle))
=&gt; {:bee 0.1, :ladybug 0.1}</code></pre></div><div><span id="add-distributions"></span><h3>4.3 &nbsp;&nbsp; add-distributions</h3></div><div><p>A helper function is defined to add distributions together</p></div><div class="code"><pre><code class="clojure">(defn add-distributions
  ([] {})
  ([m] m)
  ([m1 m2]
   (reduce-kv (fn [m k v]
                (update-in m [k] (fnil #(+ % v) 0)))
              m1
              m2))
  ([m1 m2 &amp; more]
   (apply add-distributions (add-distributions m1 m2) more)))</code></pre></div><div><p>The function is relatively generic and can be used to add arbitrary maps together:</p></div><div class="code"><pre><code class="clojure">(add-distributions {:a 0.1} {:a 0.1 :b 0.3} {:a 0.3 :c 0.3})
=&gt; {:a 0.5, :b 0.3, :c 0.3}</code></pre></div><div><span id="adjusted-distribution"></span><h3>4.4 &nbsp;&nbsp; adjusted-distribution</h3></div><div><p>Combining the three functions, we can get an adjusted distribution based on the model taken from the config:</p></div><div class="code"><pre><code class="clojure">(defn adjusted-distribution [params {:keys [default linear toggle] :as model}]
  (let [ladjust (linear-adjustment params linear)
        tadjust (toggle-adjustment params toggle)]
    (add-distributions default ladjust tadjust)))</code></pre></div><div><p>The adjusted distributions for each trap can then be calculated:</p></div><div class="code"><pre><code class="clojure">(mapv #(adjusted-distribution % (-&gt; config :model))
      (-&gt; config :traps))
=&gt; [;; kitchen
    {:fly 0.8, :ladybug 0.05,
     :mosquito 0.55, :bee 0.25}
    ;; bedroom
    {:fly 0.8, :ladybug 0.05,
     :mosquito 0.63, :bee 0.15000000000000002}
    ;; patio
    {:fly 0.5, :ladybug 0.15000000000000002,
     :mosquito 0.35, :bee 0.44999999999999996}
    ;; bathroom
    {:fly 0.8, :ladybug 0.05,
     :mosquito 0.6699999999999999, :bee 0.1}]</code></pre></div><div><span id="sampling-model"></span><h2><b>5 &nbsp;&nbsp; Sampling Model</b></h2></div><div><p>The sampling model is easier to construct. We wish to create a function that takes in a distribution and returns a key that is proportional to the values of the map:</p></div><div class="code"><pre><code class="clojure">(random-sample {:a 0.5 :b 0.5})
=&gt; ;; either returns :a or :b
#(get #{:a :b} %)</code></pre></div><div><span id="cumultive"></span><h3>5.1 &nbsp;&nbsp; cumultive</h3></div><div><p>culmultive takes a distribution and turns it into a range, sorted by value:</p></div><div class="code"><pre><code class="clojure">(defn cumultive [distribution]
  (dissoc (reduce (fn [out [k v]]
                    (let [total (::total out)
                          ntotal (+ total v)]
                      (assoc out
                             k [total ntotal]
                             ::total ntotal)))
                  {::total 0}
                  (sort-by val distribution))
          ::total))</code></pre></div><div><p>examples of its usage can be seen:</p></div><div class="code"><pre><code class="clojure">(cumultive {:a 0.3 :b 0.5 :c 0.2})
=&gt; {:c [0 0.2], :a [0.2 0.5], :b [0.5 1.0]}</code></pre></div><div><span id="category"></span><h3>5.2 &nbsp;&nbsp; category</h3></div><div><p>category takes a cumultive distribution and a point, return which section it belongs to:</p></div><div class="code"><pre><code class="clojure">(defn category [cumulative stat]
  (-&gt;&gt; cumulative
       (keep (fn [[k [lower upper]]]
               (if (&lt;= lower stat upper) k)))
       first))</code></pre></div><div><p>examples of its usage can be seen:</p></div><div class="code"><pre><code class="clojure">(def dist (cumultive {:a 0.3 :b 0.5 :c 0.2}))
;; {:c [0 0.2], :a [0.2 0.5], :b [0.5 1.0]} 0.1


(category dist 0.1) =&gt; :c

(category dist 0.3) =&gt; :a

(category dist 0.8) =&gt; :b</code></pre></div><div><span id="random-sample"></span><h3>5.3 &nbsp;&nbsp; random-sample</h3></div><div><p>Now the <code>random-sample</code> function can be written:</p></div><div class="code"><pre><code class="clojure">(defn random-sample [distribution]
  (let [total (apply + (vals distribution))
        stat  (rand total)]
    (category (cumultive distribution) stat)))</code></pre></div><div><p>We can now use this with a probability map:</p></div><div class="code"><pre><code class="clojure">(random-sample {:a 0.3 :b 0.5 :c 0.2})
=&gt; ;; Returns either :a :b or :c
#(get #{:a :b :c} %)</code></pre></div><div><p>As well as with <code>adjusted-model</code> defined in the <a href='#probability-models'>previous chapter</a></p></div><div class="code"><pre><code class="clojure">(random-sample
 (adjusted-distribution {:brightness 0.3 :indoor true :rate 0.5}
                        (-&gt; config :model)))
=&gt; ;; Return either :fly :ladybug :mosquito :bee
#(get #{:fly :ladybug :mosquito :bee} %)</code></pre></div><div><span id="implementing-components"></span><h2><b>6 &nbsp;&nbsp; Implementing Components</b></h2></div><div><span id="model"></span><h3>6.1 &nbsp;&nbsp; Model</h3></div><div><p>We create a record for <code>Model</code>. The data is just a nested map but a record is used purely for printing purposes. There is quite alot of stuff in the map and we should be able to only show the necessary amount of information - in this case, we only want to know the keys of the datastructure:</p></div><div class="code"><pre><code class="clojure">(defrecord Model []
  Object
  (toString [obj]
    (str &quot;#model&quot; (vec (keys (into {} obj))))))

(defmethod print-method Model
  [v w]
  (.write w (str v)))</code></pre></div><div><p>We can now use the <code>map-&gt;Model</code> function to create a nicer new on the model:</p></div><div class="code"><pre><code class="clojure">(map-&gt;Model (:model config))
;;=&gt; #model[:default :linear :toggle]</code></pre></div><div><span id="trap"></span><h3>6.2 &nbsp;&nbsp; Trap</h3></div><div><p><code>Trap</code> is a component that needs to be started and stopped. It simulates a trap that knows what insect went inside the trap, what time it entered and if it had been captured. We create a basic function for one round of the trapping an insect:</p></div><div class="code"><pre><code class="clojure">(defn trap-bug [{:keys [rate efficiency fuzziness model output] :as trap}]
  (let [pause   (long (* (+ rate
                            (* (- (rand 1) 0.5) fuzziness))
                         1000))]
    (Thread/sleep pause)
    (reset! output
           {:time (java.util.Date.)
            :bug (random-sample
                  (adjusted-distribution trap model))
            :captured (&lt; (rand 1) efficiency)})
    trap))</code></pre></div><div><p>The usage for such a function can be seen below:</p></div><div class="code"><pre><code class="clojure">(-&gt; (trap-bug {:rate 0.8
               :efficiency 0.5
               :fuzziness 0.1
               :model (:model config)
               :output (atom nil)})
    :output
    deref)
=&gt; (contains {:time #(instance? java.util.Date %)
              :bug #(#{:fly :bee :ladybug :mosquito} %)
              :captured #(instance? Boolean %)})</code></pre></div><div><p>We create a record that implements the <code>IComponent</code> interface, making sure that we hide keys that are not useful</p></div><div class="code"><pre><code class="clojure">(defrecord Trap []
  Object
  (toString [obj]
    (let [selected [:location :output]]
      (str &quot;#trap&quot; (-&gt; (into {} obj)
                       (select-keys selected)
                       (update-in [:output] deref)))))

  component/IComponent
  (-start [trap]
    (assoc trap
           :thread (future
                     (println (str &quot;Starting trap in &quot;
                                   (:location trap) &quot;&#92;n&quot;))
                     (last (iterate trap-bug trap)))))

  (-stop [{:keys [thread output] :as trap}]
    (do
      (println (str &quot;Stopping trap in &quot; (:location trap)))
      (future-cancel thread)
      (reset! output nil)
      (dissoc trap :thread))))

(defmethod print-method Trap
  [v w]
  (.write w (str v)))</code></pre></div><div><p>Finally, we create a <code>trap</code> constructor taking a config map and outputting a <code>Trap</code> record:</p></div><div class="code"><pre><code class="clojure">(defn trap [m]
  (assoc (map-&gt;Trap m)
         :output (atom nil)))</code></pre></div><div><span id="partial-system-testing"></span><h3>6.3 &nbsp;&nbsp; Partial System Testing</h3></div><div><p>Having implemented the records for <code>:traps</code> and <code>:model</code>, we can test to see if our array of traps are working. The call to system takes two parameters - a topology map and a configuration map. The topology map specifies functions and dependencies whilst the configuration map specifies the initial input data. Note that to specify contruction of an array of components put the constructor in an additional vector:</p></div><div class="code"><pre><code class="clojure">(def topology {:traps [[trap] :model]
               :model [map-&gt;Model]})

(def sys (-&gt; (component/system toplogy config)
             (component/start)))
;; Starting trap in patio
;; Starting trap in bathroom
;; Starting trap in kitchen
;; Starting trap in bedroom


(add-watch (-&gt; sys :traps first :output)
           :print-change
           (fn [_ _ _ n]
             (if (:captured n)
               (println n))))
;; {:time #inst &quot;2015-07-15T08:21:33.690-00:00&quot;, :bug :fly, :captured true}
;; {:time #inst &quot;2015-07-15T08:21:34.216-00:00&quot;, :bug :mosquito, :captured true}
;; ....
;; ....
;; {:time #inst &quot;2015-07-15T08:21:36.753-00:00&quot;, :bug :fly, :captured false}

(remove-watch (-&gt; sys :traps first :output) :print-change)
;; &lt;CONSOLE OUTPUT STOPS&gt;

(component/stop sys)
;;=&gt; {:traps #arr[#trap{:location &quot;kitchen&quot;, :output nil}
;;             #trap{:location &quot;bedroom&quot;, :output nil}
;;             #trap{:location &quot;patio&quot;, :output nil}
;;             #trap{:location &quot;bathroom&quot;, :output nil],
;;    :model #model[:default :linear :toggle]}</code></pre></div><div><span id="app"></span><h3>6.4 &nbsp;&nbsp; App</h3></div><div><p>The role of the app is to hook up the sensors to a datastore, in this case an <a href='hara-concurrent-ova.html'>ova</a>, a mutable array of elements. We define <code>initialise-app</code> to setup watches to provide some summary and coordination:</p></div><div class="code"><pre><code class="clojure">(require '[hara.concurrent.ova :as ova])

(defn initialise-app [{:keys [db traps display total] :as app}]
  (let [data (mapv (fn [trap]
                     (select-keys trap [:location]))
                   traps)]
    (dosync (ova/init! db data))
    (doseq [{:keys [location output] :as trap} traps]
      (add-watch
       output :summary
       (fn [_ _ _ {:keys [success bug]}]
         (dosync (ova/!&gt; db [:location location]
                         (update-in [:triggered]
                                    (fnil inc 0))
                         (update-in [:captured]
                                    (fnil #(update-in % [bug] (fnil inc 0))
                                          {}))))
         (swap! total update-in [bug] (fnil inc 0))))))
  app)</code></pre></div><div><p>The opposite method <code>deinitialise-app</code> is also defined:</p></div><div class="code"><pre><code class="clojure">(defn deinitialise-app [{:keys [db traps total] :as app}]
  (dosync (ova/empty! db))
  (reset! total {})
  (doseq [{:keys [output]} traps]
    (remove-watch output :summary))
  app)</code></pre></div><div><p>The two functions are then hooked up via <code>-start</code> and <code>-stop</code> protocol methods for the component architecture:</p></div><div class="code"><pre><code class="clojure">(defrecord App []
  Object
  (toString [app]
    (str &quot;#app&quot; (-&gt; app keys vec)))

  component/IComponent
  (-start [app]
    (initialise-app app)
    app)

  (-stop [app]
    (deinitialise-app app)
    app))

(defmethod print-method App
  [v w]
  (.write w (str v)))

(defn app [m]
  (assoc (map-&gt;App m) :total (atom {})))</code></pre></div><div><span id="app-testing"></span><h3>6.5 &nbsp;&nbsp; App Testing</h3></div><div><p>We can now do a more testing by including a couple more constructors. Note that the keys <code>:db</code>, <code>app</code> and <code>summary</code> have been added. Also see the syntax for the <code>:summary</code> topology to expose the <code>:total</code> submap from <code>:app</code>.</p><p>The syntax for the <code>:summary</code> key should be further explained. What <code>component/start</code> sees a initialisation of {:expose [:total]}, it take the first dependency (in this case, <code>:app</code>), gets the <code>:total</code> submap and exposes it as <code>:summary</code> in the system map. The value of <code>:expose</code> can be either a vector (for nested map supprt) or a function for more generic operations. This promotes reuse and composition of multiple systems.</p></div><div class="code"><pre><code class="clojure">(def topology {:traps   [[trap] :model]
               :model   [map-&gt;Model]
               :db      [ova/ova]
               :app     [app :traps :db]
               :summary [{:expose [:total]} :app]})

(def sys (-&gt; (component/system topology config)
             (component/start)))
;; Starting trap in patio
;; Starting trap in bathroom
;; Starting trap in kitchen
;; Starting trap in bedroom


@(:summary sys) ;; first call to :summary gives a set of bugs trapped
;;=&gt; {:mosquito 101, :fly 120, :ladybug 6, :bee 28}

@(:summary sys) ;; second call to :summary gives an updated of bugs trapped
;;=&gt; {:mosquito 148, :fly 184, :ladybug 12, :bee 37}

(component/stop sys)
;; Stopping trap in kitchen
;; Stopping trap in bedroom
;; Stopping trap in patio
;; Stopping trap in bathroom

;;=&gt; {:app #app[:display :total],
;;    :db #ova [],
;;    :traps #arr[#trap{:location &quot;kitchen&quot;,  :output nil}
;;                #trap{:location &quot;bedroom&quot;,  :output nil}
;;                #trap{:location &quot;patio&quot;,    :output nil}
;;                #trap{:location &quot;bathroom&quot;, :output nil}]
;;    :model #model[:default :linear :toggle]}</code></pre></div><div><span id="server"></span><h3>6.6 &nbsp;&nbsp; Server</h3></div><div><p>The server requires a couple of external dependencies:</p></div><div class="code"><pre><code class="clojure">(require '[compojure.core :as routes]
         '[ring.adapter.jetty :as jetty]
         '[clj-http.client :as client])</code></pre></div><div><p>We define a very simple server with one route that just returns the summary as a string:</p></div><div class="code"><pre><code class="clojure">(defn make-routes
  [{:keys [summary] :as serv}]
  (routes/GET &quot;*&quot; [] (str @summary)))

(defrecord Server []
  Object
  (toString [serv]
    (str &quot;#server&quot; (-&gt; serv keys vec)))

  component/IComponent
  (-start [{:keys [port summary] :as serv}]
    (println (str &quot;STARTING SERVER on port &quot; port))
    (assoc serv
           :instance (jetty/run-jetty (make-routes serv)
                                      {:join? false
                                       :port port})))

  (-stop [{:keys [summary instance] :as serv}]
    (println (str &quot;STOPPING SERVER on port &quot; (:port serv)))
    (.stop instance)
    (dissoc serv :instance)))</code></pre></div><div><p>Again, <code>print-method</code> is defined for prettiness:</p></div><div class="code"><pre><code class="clojure">(defmethod print-method Server
  [v w]
  (.write w (str v)))</code></pre></div><div><span id="server-testing"></span><h3>6.7 &nbsp;&nbsp; Server Testing</h3></div><div><p>Again, we add an additional constructor to the system and start:</p></div><div class="code"><pre><code class="clojure">(def sys (-&gt; {:traps   [[trap] :model]
              :model   [map-&gt;Model]
              :db      [ova/ova]
              :app     [app :traps :db]
              :summary [{:expose [:total]} :app]
              :server  [map-&gt;Server :summary]}
             (component/system config)
             (component/start)))
;; Starting trap in patio
;; Starting trap in bathroom
;; Starting trap in kitchen
;; Starting trap in bedroom
;; STARTING SERVER on PORT 8090</code></pre></div><div><p>We can now use a client to access the summary via a http protocol:</p></div><div class="code"><pre><code class="clojure">;; First Time
(-&gt; (client/get &quot;http://localhost:8090/&quot;)
    :body)
;;=&gt; &quot;{:fly 249, :bee 55, :mosquito 187, :ladybug 19}&quot;


;; Second Time
(-&gt; (client/get &quot;http://localhost:8090/&quot;)
    :body)
;; =&gt; &quot;{:fly 305, :bee 70, :mosquito 227, :ladybug 26}&quot;</code></pre></div><div><p>Stopping is no different to before</p></div><div class="code"><pre><code class="clojure">(component/stop sys)
;; STOPPING SERVER on PORT 8090
;; Stopping trap in kitchen
;; Stopping trap in bedroom
;; Stopping trap in patio
;; Stopping trap in bathroom

;;=&gt; {:app #app[:display :total],
;;    :db #ova [],
;;    :traps #arr[#trap{:location &quot;kitchen&quot;,  :output nil}
;;                #trap{:location &quot;bedroom&quot;,  :output nil}
;;                #trap{:location &quot;patio&quot;,    :output nil}
;;                #trap{:location &quot;bathroom&quot;, :output nil}]
;;    :model #model[:default :linear :toggle]
;;    :server #server[:port]}</code></pre></div><div><span id="the-big-picture"></span><h2><b>7 &nbsp;&nbsp; The Big Picture</b></h2></div><div><span id="summary"></span><h3>7.1 &nbsp;&nbsp; Summary</h3></div><div><p>We have created the bug trapping system based on our <a href='#sub-system-dependencies'>dependency diagram</a>. We can visualize the essential components that make up our system in the diagram below:</p></div><div class="figure"><a id="the-system"></a><h4><i>fig.2  &nbsp;-&nbsp; the system</i></h4><div class="img"><img line="{:row 653, :col 1, :end-row 653, :end-col 84}" src="img/hara_component/system.png" title="the system" width="100%" /></div><p></p></div><div><p>The constructors and the dependencies form our system topology whilst the data that initialised our system form our config. There are significant advantages of doing this:</p><ul><li>The final code is almost the same as the diagram of the system.</li><li>There is an isometric correspondence between process and data.</li><li>It clearly seperates data (which is normally loaded from a file) from process.</li><li>It keeps all the initialisations in a single place.</li><li>Systems can be built incrementally in the way that we have just done.</li></ul></div><div><span id="further-extension"></span><h3>7.2 &nbsp;&nbsp; Further Extension</h3></div><div><p>Say we needed to add more functionality to our system, in which we define the <code>make-routes</code> method to add an endpoint giving us information about the status of the datastore:</p></div><div class="code"><pre><code class="clojure">(defn make-routes
  [{:keys [db summary] :as serv}]
  (routes/routes
    (routes/GET &quot;/total&quot; [] (str @summary))
    (routes/GET &quot;/db&quot; []    (str (persistent! db)))))</code></pre></div><div><p>It is very easy to redefine topology to include the extra dependency:</p></div><div class="code"><pre><code class="clojure">(def toplogy {:traps   [[trap] :model]
              :model   [map-&gt;Model]
              :db      [ova/ova]
              :app     [app :traps :db]
              :summary [{:expose [:total]} :app]
              :server  [map-&gt;Server :summary :db]}) ;; note the extra `:db` key

(def sys (-&gt; (component/system topology config)
             (component/start)))</code></pre></div><div><p>We can again visualize the extended system:</p></div><div class="figure"><a id="the-extended-system"></a><h4><i>fig.3  &nbsp;-&nbsp; the extended system</i></h4><div class="img"><img line="{:row 688, :col 1, :end-row 688, :end-col 94}" src="img/hara_component/system2.png" title="the extended system" width="100%" /></div><p></p></div><div><span id="links-and-resources"></span><h2><b>8 &nbsp;&nbsp; Links and Resources</b></h2></div><div><p>Here are some more links and resources on the web:</p><ul><li><a href='https://github.com/stuartsierra/component'>stuartsierra/component</a> - original library</li><li><a href='http://z.caudate.me/hara-component-just-a-bit-more-structure/'>just a bit more structure</a> - the announcement on my blog</li></ul></div>
        </div>
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

  </body>

  <script>
  if (true) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-31320512-2', 'caudate.me');
    ga('send', 'pageview');
  }
  </script>
  
  <script type="text/javascript">
    smoothScroll.init();
    gumshoe.init({});
  
    hljs.registerLanguage("clojure",function(e){var t={"builtin-name":"def defonce cond apply if-not if-let if not not= = < > <= >= == + / * - rem quot neg? pos? delay? symbol? keyword? true? false? integer? empty? coll? list? set? ifn? fn? associative? sequential? sorted? counted? reversible? number? decimal? class? distinct? isa? float? rational? reduced? ratio? odd? even? char? seq? vector? string? map? nil? contains? zero? instance? not-every? not-any? libspec? -> ->> .. . inc compare do dotimes mapcat take remove take-while drop letfn drop-last take-last drop-while while intern condp case reduced cycle split-at split-with repeat replicate iterate range merge zipmap declare line-seq sort comparator sort-by dorun doall nthnext nthrest partition eval doseq await await-for let agent atom send send-off release-pending-sends add-watch mapv filterv remove-watch agent-error restart-agent set-error-handler error-handler set-error-mode! error-mode shutdown-agents quote var fn loop recur throw try monitor-enter monitor-exit defmacro defn defn- macroexpand macroexpand-1 for dosync and or when when-not when-let comp juxt partial sequence memoize constantly complement identity assert peek pop doto proxy defstruct first rest cons defprotocol cast coll deftype defrecord last butlast sigs reify second ffirst fnext nfirst nnext defmulti defmethod meta with-meta ns in-ns create-ns import refer keys select-keys vals key val rseq name namespace promise into transient persistent! conj! assoc! dissoc! pop! disj! use class type num float double short byte boolean bigint biginteger bigdec print-method print-dup throw-if printf format load compile get-in update-in pr pr-on newline flush read slurp read-line subvec with-open memfn time re-find re-groups rand-int rand mod locking assert-valid-fdecl alias resolve ref deref refset swap! reset! set-validator! compare-and-set! alter-meta! reset-meta! commute get-validator alter ref-set ref-history-count ref-min-history ref-max-history ensure sync io! new next conj set! to-array future future-call into-array aset gen-class reduce map filter find empty hash-map hash-set sorted-map sorted-map-by sorted-set sorted-set-by vec vector seq flatten reverse assoc dissoc list disj get union difference intersection extend extend-type extend-protocol int nth delay count concat chunk chunk-buffer chunk-append chunk-first chunk-rest max min dec unchecked-inc-int unchecked-inc unchecked-dec-inc unchecked-dec unchecked-negate unchecked-add-int unchecked-add unchecked-subtract-int unchecked-subtract chunk-next chunk-cons chunked-seq? prn vary-meta lazy-seq spread list* str find-keyword keyword symbol gensym force rationalize"},r="a-zA-Z_\\-!.?+*=<>&#'",n="["+r+"]["+r+"0-9/;:]*",a="[-+]?\\d+(\\.\\d+)?",o={b:n,r:0},s={cN:"number",b:a,r:0},i=e.inherit(e.QSM,{i:null}),c=e.C(";","$",{r:0}),d={cN:"literal",b:/\b(true|false|nil)\b/},l={b:"[\\[\\{]",e:"[\\]\\}]"},m={cN:"comment",b:"\\^"+n},p=e.C("\\^\\{","\\}"),u={cN:"symbol",b:"[:]{1,2}"+n},f={b:"\\(",e:"\\)"},h={eW:!0,r:0},y={k:t,l:n,cN:"name",b:n,starts:h},b=[f,i,m,p,c,u,l,s,d,o];return f.c=[e.C("comment",""),y,h],h.c=b,l.c=b,{aliases:["clj"],i:/\S/,c:[f,i,m,p,c,u,l,s,d]}});
    hljs.initHighlightingOnLoad();
  </script>
</html>
